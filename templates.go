package plate

import (
	"bytes"
	"text/template"
)

// templateData holds all data passed to templates
type templateData struct {
	PackageName string
	Tables      []tableTemplateData
	TypeName    string
	TableName   string
	Columns     []columnInfo
	Relations   []generatedRelation
	Imports     []string
}

// tableTemplateData represents table data for templates
type tableTemplateData struct {
	TypeName  string
	TableName string
}

const tablesTemplate = `package tables

// This file is generated by plate. DO NOT EDIT.
{{range .Tables}}
// {{.TypeName}} represents the {{.TableName}} table
type {{.TypeName}} struct{}

func ({{.TypeName}}) TableName() string { return "{{.TableName}}" }
{{end}}
`

const queryBuilderTemplate = `package {{.PackageName}}

// This file is generated by plate. DO NOT EDIT.

import (
{{range .Imports}}	"{{.}}"
{{end}})

// Column accessors for type-safe column references
{{range .Columns}}func {{.Name}}() types.Column[tables.{{$.TypeName}}, {{.GoType}}] {
	return types.Column[tables.{{$.TypeName}}, {{.GoType}}]{Name: "{{.ColumnName}}"}
}

{{end}}
// Select creates a SELECT query for the {{.TypeName}} table
func Select(opts ...types.Option[tables.{{.TypeName}}]) (string, []any) {
	return query.Select(opts...)
}

// Limit adds a LIMIT clause to the query
func Limit(count int) types.QueryOption[tables.{{.TypeName}}] {
	return query.Limit[tables.{{.TypeName}}](count)
}

// OrderBy adds an ORDER BY clause to the query
func OrderBy[V any](column types.Column[tables.{{.TypeName}}, V], dir ast.Direction) types.QueryOption[tables.{{.TypeName}}] {
	return query.OrderBy(column, dir)
}

// And creates an AND condition that groups multiple conditions
func And(opts ...types.ExprOption[tables.{{.TypeName}}]) types.ExprOption[tables.{{.TypeName}}] {
	return query.And(opts...)
}

// Or creates an OR condition from multiple conditions
func Or(opts ...types.ExprOption[tables.{{.TypeName}}]) types.ExprOption[tables.{{.TypeName}}] {
	return query.Or(opts...)
}

// Not creates a logical NOT condition that wraps any ExprOption
func Not(opt types.ExprOption[tables.{{.TypeName}}]) types.ExprOption[tables.{{.TypeName}}] {
	return query.Not(opt)
}


{{range .Relations}}
{{if eq .Type "belongs_to"}}// With{{.Name}} fetches related {{.Target}} as a nested struct
func With{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.QueryOption[tables.{{$.TypeName}}] {
	return query.WithSubquery[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Name | toSnakeCase}}",
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		false, // not an array
		"",    // no junction table
		query.KeyPair{},
		opts...,
	)
}

// Where{{.Name}} filters {{$.TypeName}} by conditions on its {{.Name}}
func Where{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.ExprOption[tables.{{$.TypeName}}] {
	return query.WhereExists[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		"",    // no junction table
		query.KeyPair{},
		opts...,
	)
}
{{else if eq .Type "has_many"}}// With{{.Name}} fetches related {{.Target}} as a nested array of structs
func With{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.QueryOption[tables.{{$.TypeName}}] {
	return query.WithSubquery[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Name | toSnakeCase}}",
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		true,  // array
		"",    // no junction table
		query.KeyPair{},
		opts...,
	)
}

// Where{{.Name}} filters {{$.TypeName}} by conditions on its {{.Name}}
func Where{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.ExprOption[tables.{{$.TypeName}}] {
	return query.WhereExists[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		"",    // no junction table
		query.KeyPair{},
		opts...,
	)
}
{{else if eq .Type "many_to_many"}}// With{{.Name}} fetches related {{.Target}} through {{.JunctionTable | toSnakeCase}} as a nested array of structs
func With{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.QueryOption[tables.{{$.TypeName}}] {
	return query.WithSubquery[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Name | toSnakeCase}}",
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		true,  // array
		"{{.JunctionTable | toSnakeCase}}",
		query.KeyPair{From: "{{.JunctionKeys.From | toSnakeCase}}", To: "{{.JunctionKeys.To | toSnakeCase}}"},
		opts...,
	)
}

// Where{{.Name}} filters {{$.TypeName}} by conditions on its {{.Name}}
func Where{{.Name}}(opts ...types.Option[tables.{{.Target}}]) types.ExprOption[tables.{{$.TypeName}}] {
	return query.WhereExists[tables.{{$.TypeName}}, tables.{{.Target}}](
		"{{.Target | toSnakeCase}}",
		query.KeyPair{From: "{{.Keys.From | toSnakeCase}}", To: "{{.Keys.To | toSnakeCase}}"},
		"{{.JunctionTable | toSnakeCase}}",
		query.KeyPair{From: "{{.JunctionKeys.From | toSnakeCase}}", To: "{{.JunctionKeys.To | toSnakeCase}}"},
		opts...,
	)
}
{{end}}{{end}}
`

// getTemplates returns initialized templates
func getTemplates() (*template.Template, error) {
	funcMap := template.FuncMap{
		"toSnakeCase": toSnakeCase,
	}

	tmpl := template.New("generator").Funcs(funcMap)

	// Parse tables template
	if _, err := tmpl.New("tables").Parse(tablesTemplate); err != nil {
		return nil, err
	}

	// Parse query builder template
	if _, err := tmpl.New("queryBuilder").Parse(queryBuilderTemplate); err != nil {
		return nil, err
	}

	return tmpl, nil
}

// renderTemplate renders a template with the given data
func renderTemplate(tmpl *template.Template, name string, data interface{}) (string, error) {
	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, name, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}
