// Code generated by plate; DO NOT EDIT.

package post

import (
	"github.com/cloudspannerecosystem/memefish/ast"
	"github.com/rail44/plate/examples/generated/tables"
	"github.com/rail44/plate/query"
	"github.com/rail44/plate/types"
	"time"
)

// Column accessors for type-safe column references
func ID() types.Column[tables.Post, string] {
	return types.Column[tables.Post, string]{Name: "id"}
}

func UserID() types.Column[tables.Post, string] {
	return types.Column[tables.Post, string]{Name: "user_id"}
}

func Title() types.Column[tables.Post, string] {
	return types.Column[tables.Post, string]{Name: "title"}
}

func Content() types.Column[tables.Post, string] {
	return types.Column[tables.Post, string]{Name: "content"}
}

func CreatedAt() types.Column[tables.Post, time.Time] {
	return types.Column[tables.Post, time.Time]{Name: "created_at"}
}

// Select creates a SELECT query for the Post table
func Select(opts ...types.Option[tables.Post]) (string, []any) {
	return query.Select(opts...)
}

// Limit adds a LIMIT clause to the query
func Limit(count int) types.QueryOption[tables.Post] {
	return query.Limit[tables.Post](count)
}

// OrderBy adds an ORDER BY clause to the query
func OrderBy[V any](column types.Column[tables.Post, V], dir ast.Direction) types.QueryOption[tables.Post] {
	return query.OrderBy(column, dir)
}

// And creates an AND condition that groups multiple conditions
func And(opts ...types.ExprOption[tables.Post]) types.ExprOption[tables.Post] {
	return query.And(opts...)
}

// Or creates an OR condition from multiple conditions
func Or(opts ...types.ExprOption[tables.Post]) types.ExprOption[tables.Post] {
	return query.Or(opts...)
}

// Not creates a logical NOT condition that wraps any ExprOption
func Not(opt types.ExprOption[tables.Post]) types.ExprOption[tables.Post] {
	return query.Not(opt)
}

// WithAuthor fetches related User as a nested struct
func WithAuthor(opts ...types.Option[tables.User]) types.QueryOption[tables.Post] {
	return query.WithOne[tables.Post, tables.User](
		"author",
		"user",
		query.KeyPair{From: "user_id", To: "id"},
		opts...,
	)
}

// WhereAuthor filters Post by conditions on its Author
func WhereAuthor(opts ...types.Option[tables.User]) types.ExprOption[tables.Post] {
	return query.WhereExists[tables.Post, tables.User](
		"user",
		query.KeyPair{From: "user_id", To: "id"},
		"", // no junction table
		query.KeyPair{},
		opts...,
	)
}

// WithTags fetches related Tag through post_tag as a nested array of structs
func WithTags(opts ...types.Option[tables.Tag]) types.QueryOption[tables.Post] {
	return query.WithManyThrough[tables.Post, tables.Tag](
		"tags",
		"tag",
		query.KeyPair{From: "id", To: "post_id"},
		"post_tag",
		query.KeyPair{From: "tag_id", To: "id"},
		opts...,
	)
}

// WhereTags filters Post by conditions on its Tags
func WhereTags(opts ...types.Option[tables.Tag]) types.ExprOption[tables.Post] {
	return query.WhereExists[tables.Post, tables.Tag](
		"tag",
		query.KeyPair{From: "id", To: "post_id"},
		"post_tag",
		query.KeyPair{From: "tag_id", To: "id"},
		opts...,
	)
}
